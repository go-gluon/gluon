package main

import (
	"fmt"
	"go/types"
	"log"
	"os"
	"strings"
	"text/template"

	"golang.org/x/tools/go/packages"
)

var standardPackages = make(map[string]struct{})

func init() {
	pkgs, err := packages.Load(nil, "std", "golang.org/x/...")
	if err != nil {
		panic(err)
	}
	for _, pkg := range pkgs {
		standardPackages[pkg.PkgPath] = struct{}{}
	}
}

func isStandardPackage(pkg string) bool {
	_, ok := standardPackages[pkg]
	return ok
}

type ExtensionDef struct {
	Import string
	Struct string
}

type ExtensionParser struct {
	Package    string
	Resources  string
	Extensions map[string]ExtensionDef
}

func (p ExtensionParser) IsResource() bool {
	return len(p.Resources) > 0
}

func main() {
	resources := ""
	if len(os.Args) > 1 {
		resources = os.Args[1]
	} else {
		if _, err := os.Stat("resources"); !os.IsNotExist(err) {
			resources = "resources/*"
		}
	}

	pkg, _ := os.LookupEnv("GOPACKAGE")
	ep := &ExtensionParser{Package: pkg, Resources: resources, Extensions: map[string]ExtensionDef{}}

	processPackages(".", ep)

	tmpl, err := template.New("gluon").Parse(templateSource)
	if err != nil {
		panic(err)
	}

	f, err := os.Create(fileName() + "_gluon.go")
	if err != nil {
		log.Println("create file: ", err)
		return
	}
	err = tmpl.Execute(f, ep)
	if err != nil {
		log.Println("Error execute template: ", err)
		return
	}
}

func fileName() string {
	fullname, _ := os.LookupEnv("GOFILE")
	if pos := strings.LastIndexByte(fullname, '.'); pos != -1 {
		return fullname[:pos]
	}
	return fullname
}

func processPackages(path string, ep *ExtensionParser) {
	mod := packages.NeedName | packages.NeedImports | packages.NeedTypes | packages.NeedTypesSizes | packages.NeedTypesInfo
	cfg := &packages.Config{Mode: mod}
	pkgs, err := packages.Load(cfg, "./...")
	if err != nil {
		panic(fmt.Errorf("loading packages for inspection: %v", err))
	}
	if packages.PrintErrors(pkgs) > 0 {
		return
	}
	for _, p := range pkgs {
		processPackage(p, ep)
	}
}

func processPackage(p *packages.Package, ep *ExtensionParser) {
	for _, name := range p.Types.Scope().Names() {
		obj := p.Types.Scope().Lookup(name)
		if _, ok := obj.(*types.TypeName); !ok {
			continue
		}

		nt, ok := obj.Type().(*types.Named)
		if ok {
			_, ok := nt.Underlying().(*types.Struct)
			if !ok {
				continue
			}
			if nt.NumMethods() > 0 {
				exit := false
				for i := 0; i < nt.NumMethods() && !exit; i++ {
					m := nt.Method(i)
					if m.Name() == "NewExtension" && m.Type().String() == "func() github.com/go-gluon/gluon.Extension" {
						ep.Extensions[p.PkgPath] = ExtensionDef{Import: p.PkgPath, Struct: p.Name + "." + name}
						exit = true
					}
				}
			}
		}

	}

	if len(p.Imports) > 0 {
		for k, v := range p.Imports {
			if !isStandardPackage(k) {
				processPackage(v, ep)
			}
		}
	}
}

var templateSource = `
// Code generated by gluon; DO NOT EDIT.
package {{.Package}}

import (
    {{ if .IsResource }}"embed"{{ end }}
    "github.com/go-gluon/gluon"
{{range $key, $value := .Extensions}}    "{{ $key }}"
{{end}})

{{ if .IsResource }}
//go:embed {{.Resources}}
var resources embed.FS
{{ end }}

var _ = gluon.RegisterExtensions({{ if .IsResource }}&resources{{ else }}nil{{ end }},
{{range $key, $value := .Extensions}}    new({{ $value.Struct }}),
{{end}})

func init() {
	gluon.Init()
}
`
